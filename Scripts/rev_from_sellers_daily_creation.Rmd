```{r}

setwd("C://Users//willf//OneDrive//Documents//NYDSA//R//Olist//Data")

# Looking at various dataframe sizes to understand what I can use


str(orders_items)

```

```{r}
# Ensure orders_items is loaded and dplyr, lubridate are available
library(dplyr)
library(lubridate)
library(tidyr)

# Convert order_purchase_timestamp to Date type, ensuring NAs are handled
orders_items$order_purchase_date <- as.Date(orders_items$order_purchase_timestamp)

# Filter for delivered orders and exclude NA dates
delivered_orders <- orders_items %>%
  filter(order_status == "delivered" & !is.na(order_purchase_date))

# Now, calculate the min and max dates ensuring they are finite
date_range <- range(delivered_orders$order_purchase_date)

# Create a sequence of dates to ensure all days are included
all_dates <- seq.Date(date_range[1], date_range[2], by="day")

# Aggregate to get daily revenue and calculate Olist's share
rev_from_sellers <- delivered_orders %>%
  group_by(order_purchase_date) %>%
  summarise(seller_revenue = sum(price), .groups = 'drop') %>%
  right_join(data.frame(order_purchase_date = all_dates), by = "order_purchase_date") %>%
  replace_na(list(seller_revenue = 0)) %>%
  mutate(olist_rev_share = seller_revenue * 0.2)

# Preview the revised DataFrame
head(rev_from_sellers)

```


```{r}
# Get daily subscription revenue from monthly_seller_stats DF
library(dplyr)
library(lubridate)

# Convert 'month' to Date format (assuming it represents the first day of each month)
monthly_seller_stats$month <- as.Date(as.character(monthly_seller_stats$month))

# Calculate daily subscription revenue directly within the monthly_seller_stats
monthly_seller_stats <- monthly_seller_stats %>%
  mutate(
    days_in_month = days_in_month(month),
    daily_subscription_revenue = monthly_subscription_revenue / days_in_month
  )

# Now, create a sequence of dates for each month and replicate the daily subscription revenue for each day
daily_revenue <- list()

for(i in 1:nrow(monthly_seller_stats)) {
  # For each month, create a sequence of dates
  month_dates <- seq.Date(monthly_seller_stats$month[i], 
                          by = "day", 
                          length.out = monthly_seller_stats$days_in_month[i])
  
  # Create a data frame for this month with daily revenue
  month_daily_revenue <- data.frame(
    date = month_dates,
    daily_subscription_revenue = rep(monthly_seller_stats$daily_subscription_revenue[i], monthly_seller_stats$days_in_month[i])
  )
  
  # Append this month's daily revenue to the list
  daily_revenue[[i]] <- month_daily_revenue
}

# Combine all monthly data frames into a single data frame
daily_revenue_df <- do.call(rbind, daily_revenue)

# Take a look at the resulting daily revenue data frame
print(daily_revenue_df)



```
```{r}
str(daily_revenue_df)
```


```{r}
print(rev_from_sellers)
```

```{r}
str(monthly_seller_stats)
```
```{r}
# Merge rev_from_sellers with daily_revenue_df
merged_df <- merge(rev_from_sellers, daily_revenue_df, by.x = "order_purchase_date", by.y = "date", all = TRUE)

# Check the first few rows of the merged data frame
str(merged_df)

```
```{r}
library(dplyr)
library(tidyr)
library(lubridate)

# Create a sequence of dates for each row and repeat the row values for each day in the month
monthly_seller_stats_daily <- monthly_seller_stats %>%
  mutate(
    month_end = month %m+% months(1) - days(1)  # Calculate the last day of each month
  ) %>%
  rowwise() %>%
  mutate(
    dates = list(seq.Date(month, month_end, by = "day"))  # Create a list of dates for each month
  ) %>%
  unnest(dates) %>%
  select(-month_end) %>%
  rename(date = dates)

# Since daily_subscription_revenue is already calculated, we can directly use it, assuming it should be constant for each day of the month
# If you need to adjust or calculate new columns based on daily data, you can add those operations here

# Check the structure of the newly created daily DataFrame
print(monthly_seller_stats_daily)


```
```{r}
# Merge monthly_seller_stats_daily with merged_df
# Rename 'date' in monthly_seller_stats_daily to 'order_purchase_date' for a consistent merge key
monthly_seller_stats_daily_renamed <- monthly_seller_stats_daily %>%
  rename(order_purchase_date = date)

# Merge the two data frames on 'order_purchase_date'
final_merged_df <- merge(merged_df, monthly_seller_stats_daily_renamed, by = "order_purchase_date", all = TRUE)

# Check the first few rows of the final merged data frame
print(final_merged_df)

```
```{r}
# Remove daily_subscription_revenue.y and rename daily_subscription_revenue.x to daily_subscription_revenue
final_merged_df <- final_merged_df %>%
  select(-daily_subscription_revenue.y) %>%
  rename(daily_subscription_revenue = daily_subscription_revenue.x)

# Check the first few rows of the adjusted final merged data frame
head(final_merged_df)

```

```{r}
# add column for seller_avg_revenue
library(dplyr)

final_merged_df <- final_merged_df %>%
  mutate(seller_avg_revenue = seller_revenue / total_sellers_subscribed)

# Check the first few rows to confirm the new column
print(final_merged_df)

```

```{r}
library(dplyr)
library(zoo)

# Adjust the dataset to the specified date range
final_merged_df_filtered <- final_merged_df %>%
  filter(order_purchase_date >= as.Date("2017-01-01") & order_purchase_date <= as.Date("2018-08-31"))

# Calculate 10-day moving averages
final_merged_df_filtered <- final_merged_df_filtered %>%
  arrange(order_purchase_date) %>%
  mutate(
    olist_rev_share_10DMA = rollmean(olist_rev_share, 10, fill = NA, align = "right"),
    daily_subscription_revenue_10DMA = rollmean(daily_subscription_revenue, 10, fill = NA, align = "right")
  )

# Check the first few rows to confirm the new columns
print(final_merged_df_filtered)

```


```{r}
# Calc 10D MA and plot


library(ggplot2)
library(tidyr)

# Reshape the data into a long format
rev_split <- final_merged_df_filtered %>%
  select(order_purchase_date, olist_rev_share_10DMA, daily_subscription_revenue_10DMA) %>%
  pivot_longer(-order_purchase_date, names_to = "Revenue Type", values_to = "Amount")

# Plotting the stacked area chart
ggplot(rev_split, aes(x = order_purchase_date, y = Amount, fill = `Revenue Type`)) +
  geom_area(position = "stack", alpha = 0.6) +
  scale_fill_manual(values = c("olist_rev_share_10DMA" = "lightcoral", 
                               "daily_subscription_revenue_10DMA" = "steelblue")) +
  labs(title = "10-Day Moving Averages of Olist Revenue Share and Daily Subscription Revenue",
       x = "Date",
       y = "10-Day Moving Average (DMA)",
       fill = "Revenue Type") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

saveRDS(rev_split, "rev_split.rds")


```
```{r}
summary(final_merged_df_filtered)
```
```{r}
library(dplyr)
library(ggplot2)

# Assuming final_merged_df_filtered is your dataset

# Step 1: Replace NA values with 0 in the specified columns
final_merged_df_filtered <- final_merged_df_filtered %>%
  mutate(
    seller_revenue = ifelse(is.na(seller_revenue), 0, seller_revenue),
    daily_subscription_revenue = ifelse(is.na(daily_subscription_revenue), 0, daily_subscription_revenue),
    olist_rev_share = ifelse(is.na(olist_rev_share), 0, olist_rev_share),
    total_sellers_subscribed = ifelse(is.na(total_sellers_subscribed), 0, total_sellers_subscribed)
  )

# Step 2: Define the function to adjust base value
adjust_base_value <- function(series) {
  non_na_non_zero <- series[series > 0][1]
  if (length(non_na_non_zero) == 0) return(NA)  # Return NA if all values are zero or NA
  return(non_na_non_zero)
}

# Find base values for each column
base_seller_revenue <- adjust_base_value(final_merged_df_filtered$seller_revenue)
base_daily_subscription_revenue <- adjust_base_value(final_merged_df_filtered$daily_subscription_revenue)
base_olist_rev_share <- adjust_base_value(final_merged_df_filtered$olist_rev_share)
base_total_sellers_subscribed <- adjust_base_value(final_merged_df_filtered$total_sellers_subscribed)

# Step 3: Calculate the percentage change from the base
final_merged_df_filtered <- final_merged_df_filtered %>%
  mutate(
    seller_revenue_index = 100 * seller_revenue / base_seller_revenue,
    daily_subscription_revenue_index = 100 * daily_subscription_revenue / base_daily_subscription_revenue,
    olist_rev_share_index = 100 * olist_rev_share / base_olist_rev_share,
    total_sellers_subscribed_index = 100 * total_sellers_subscribed / base_total_sellers_subscribed
  )

summary(final_merged_df_filtered)

```

```{r}
library(dplyr)
library(ggplot2)
library(zoo)

# Assuming final_merged_df_filtered is your dataset

# Step 1: Replace NA values with 0 in the specified columns
final_merged_df_filtered <- final_merged_df_filtered %>%
  mutate(
    seller_revenue = ifelse(is.na(seller_revenue), 0, seller_revenue),
    daily_subscription_revenue = ifelse(is.na(daily_subscription_revenue), 0, daily_subscription_revenue),
    olist_rev_share = ifelse(is.na(olist_rev_share), 0, olist_rev_share),
    total_sellers_subscribed = ifelse(is.na(total_sellers_subscribed), 0, total_sellers_subscribed)
  )

# Step 2: Define the function to adjust base value
adjust_base_value <- function(series) {
  non_na_non_zero <- series[series > 0][1]
  if (length(non_na_non_zero) == 0) return(NA)  # Return NA if all values are zero or NA
  return(non_na_non_zero)
}

# Find base values for each column
base_seller_revenue <- adjust_base_value(final_merged_df_filtered$seller_revenue)
base_daily_subscription_revenue <- adjust_base_value(final_merged_df_filtered$daily_subscription_revenue)
base_olist_rev_share <- adjust_base_value(final_merged_df_filtered$olist_rev_share)
base_total_sellers_subscribed <- adjust_base_value(final_merged_df_filtered$total_sellers_subscribed)

# Step 3: Calculate the percentage change from the base
final_merged_df_filtered <- final_merged_df_filtered %>%
  mutate(
    seller_revenue_index = 100 * seller_revenue / base_seller_revenue,
    daily_subscription_revenue_index = 100 * daily_subscription_revenue / base_daily_subscription_revenue,
    olist_rev_share_index = 100 * olist_rev_share / base_olist_rev_share,
    total_sellers_subscribed_index = 100 * total_sellers_subscribed / base_total_sellers_subscribed
  )

# Add 30-day moving averages for each metric
final_merged_df_filtered <- final_merged_df_filtered %>%
  mutate(
    daily_subscription_revenue_ma30 = rollmean(daily_subscription_revenue, k = 30, fill = NA),
    olist_rev_share_ma30 = rollmean(olist_rev_share, k = 30, fill = NA),
    total_sellers_subscribed_ma30 = rollmean(total_sellers_subscribed, k = 30, fill = NA),
    seller_revenue_index_ma30 = rollmean(seller_revenue_index, k = 30, fill = NA)
  )

saveRDS(final_merged_df_filtered, "final_merged_df_filtered.rds")

# Create a ggplot object for the first three metrics
p <- ggplot(final_merged_df_filtered, aes(x = order_purchase_date)) +
  geom_line(aes(y = daily_subscription_revenue_ma30, color = "Daily Subscription Revenue")) +
  geom_line(aes(y = olist_rev_share_ma30, color = "Olist Revenue Share")) +
  geom_line(aes(y = total_sellers_subscribed_ma30, color = "Total Sellers Subscribed")) +
  scale_y_continuous(sec.axis = sec_axis(~. * base_seller_revenue/100, name = "Seller Revenue Index")) +  # Define secondary y-axis for seller revenue index
  labs(x = "Order Purchase Date", y = "Metrics") +
  ggtitle("Olist and Seller Performance Index Comparison")  # Add chart title

# Plot the seller_revenue index on the secondary y-axis
p <- p +
  geom_line(aes(y = seller_revenue_index_ma30, color = "Seller Revenue Index")) +  # Use the calculated 30-day moving average for seller revenue index
  scale_color_manual(values = c("Daily Subscription Revenue" = "red", 
                                 "Olist Revenue Share" = "blue", 
                                 "Total Sellers Subscribed" = "green",
                                 "Seller Revenue Index" = "black")) +
  theme(legend.title = element_blank())  # Remove legend title

# Manually specify the color and label for each line in the legend
p <- p + guides(color = guide_legend(override.aes = list(
  "Daily Subscription Revenue" = "red",
  "Olist Revenue Share" = "blue",
  "Total Sellers Subscribed" = "green",
  "Seller Revenue Index" = "black"
)))

# Display the plot
print(p)





```


```{r}
library(dplyr)

# Assuming final_merged_df_filtered is your dataset

# Step 1: Replace NA values with 0 in the specified columns
final_merged_df_filtered <- final_merged_df_filtered %>%
  mutate(
    seller_revenue = ifelse(is.na(seller_revenue), 0, seller_revenue),
    daily_subscription_revenue = ifelse(is.na(daily_subscription_revenue), 0, daily_subscription_revenue),
    olist_rev_share = ifelse(is.na(olist_rev_share), 0, olist_rev_share),
    total_sellers_subscribed = ifelse(is.na(total_sellers_subscribed), 0, total_sellers_subscribed)
  )

# Step 2: Define the function to adjust base value
adjust_base_value <- function(series) {
  non_na_non_zero <- series[series > 0][1]
  if (length(non_na_non_zero) == 0) return(NA)  # Return NA if all values are zero or NA
  return(non_na_non_zero)
}

# Find base values for each column
base_seller_revenue <- adjust_base_value(final_merged_df_filtered$seller_revenue)
base_daily_subscription_revenue <- adjust_base_value(final_merged_df_filtered$daily_subscription_revenue)
base_olist_rev_share <- adjust_base_value(final_merged_df_filtered$olist_rev_share)
base_total_sellers_subscribed <- adjust_base_value(final_merged_df_filtered$total_sellers_subscribed)

# Step 3: Calculate the percentage change from the base
final_merged_df_filtered <- final_merged_df_filtered %>%
  mutate(
    seller_revenue_change = 100 * (seller_revenue - base_seller_revenue) / base_seller_revenue,
    daily_subscription_revenue_change = 100 * (daily_subscription_revenue - base_daily_subscription_revenue) / base_daily_subscription_revenue,
    olist_rev_share_change = 100 * (olist_rev_share - base_olist_rev_share) / base_olist_rev_share,
    total_sellers_subscribed_change = 100 * (total_sellers_subscribed - base_total_sellers_subscribed) / base_total_sellers_subscribed
  )

# Optional: Remove Inf values post-calculation, replacing them with NA
final_merged_df_filtered <- final_merged_df_filtered %>%
  mutate(
    seller_revenue_change = ifelse(is.infinite(seller_revenue_change), NA, seller_revenue_change),
    daily_subscription_revenue_change = ifelse(is.infinite(daily_subscription_revenue_change), NA, daily_subscription_revenue_change),
    olist_rev_share_change = ifelse(is.infinite(olist_rev_share_change), NA, olist_rev_share_change),
    total_sellers_subscribed_change = ifelse(is.infinite(total_sellers_subscribed_change), NA, total_sellers_subscribed_change)
  )


```

```{r}
# Calc 30DMA
library(dplyr)
library(zoo) # For rolling averages

# Calculating percentage change might already be done; ensure moving averages are calculated as follows:
final_merged_df_filtered <- final_merged_df_filtered %>%
  arrange(order_purchase_date) %>% # Ensure data is ordered by date
  mutate(
    seller_revenue_ma30 = rollmean(seller_revenue_change, 30, fill = NA, align = 'right'),
    daily_subscription_revenue_ma30 = rollmean(daily_subscription_revenue_change, 30, fill = NA, align = 'right'),
    olist_rev_share_ma30 = rollmean(olist_rev_share_change, 30, fill = NA, align = 'right'),
    total_sellers_subscribed_ma30 = rollmean(total_sellers_subscribed_change, 30, fill = NA, align = 'right')
  )

```


```{r}
# Normalize, Reshape and plot
library(ggplot2)
library(dplyr)
library(scales) # For rescaling functions

# Find the ratio to scale seller_revenue to fit the scale of other metrics
max_seller_revenue <- max(final_merged_df_filtered$seller_revenue_ma30, na.rm = TRUE)
max_other_metrics <- max(final_merged_df_filtered$daily_subscription_revenue_ma30,
                         final_merged_df_filtered$olist_rev_share_ma30,
                         final_merged_df_filtered$total_sellers_subscribed_ma30, na.rm = TRUE)

scaling_factor <- max_other_metrics / max_seller_revenue

# Create a new column for the scaled seller_revenue
final_merged_df_filtered <- final_merged_df_filtered %>%
  mutate(seller_revenue_ma30_scaled = seller_revenue_ma30 * scaling_factor)

# Plot with ggplot2 using a dual y-axis
ggplot(data = final_merged_df_filtered, aes(x = order_purchase_date)) +
  geom_line(aes(y = daily_subscription_revenue_ma30, color = "Daily Subscription Revenue")) +
  geom_line(aes(y = olist_rev_share_ma30, color = "Olist Rev Share")) +
  geom_line(aes(y = total_sellers_subscribed_ma30, color = "Total Sellers Subscribed")) +
  geom_line(aes(y = seller_revenue_ma30_scaled, color = "Seller Revenue")) +
  scale_y_continuous(
    name = "Other Metrics (30-Day MA)",
    sec.axis = sec_axis(trans = ~ . / scaling_factor, name = "Seller Revenue (30-Day MA)")
  ) +
  scale_color_manual(values = c("Daily Subscription Revenue" = "red",
                                "Olist Rev Share" = "green",
                                "Total Sellers Subscribed" = "purple",
                                "Seller Revenue" = "blue")) +
  theme_minimal() +
  labs(
    title = "30-Day Moving Averages of Key Metrics Over Time",
    x = "Order Purchase Date",
    y = "30-Day MA Value",
    color = "Metrics"
  )



```

```{r}
# Find the ratio to scale seller_revenue_ma30 to fit the scale of other metrics
max_seller_revenue_ma30 <- max(final_merged_df_filtered$seller_revenue_ma30, na.rm = TRUE)
max_other_metrics_ma30 <- max(final_merged_df_filtered$daily_subscription_revenue_ma30,
                              final_merged_df_filtered$olist_rev_share_ma30,
                              final_merged_df_filtered$total_sellers_subscribed_ma30, na.rm = TRUE)

scaling_factor <- max_other_metrics_ma30 / max_seller_revenue_ma30

# Create a new column for the scaled seller_revenue_ma30
final_merged_df_filtered <- final_merged_df_filtered %>%
  mutate(seller_revenue_ma30_scaled = seller_revenue_ma30 * scaling_factor)

# Plot with ggplot2 using a dual y-axis
ggplot(data = final_merged_df_filtered, aes(x = order_purchase_date)) +
  geom_line(aes(y = seller_revenue_ma30_scaled, color = "Seller Revenue"), size = 1.2) +
  geom_line(aes(y = daily_subscription_revenue_ma30, color = "Daily Subscription Revenue")) +
  geom_line(aes(y = olist_rev_share_ma30, color = "Olist Rev Share")) +
  geom_line(aes(y = total_sellers_subscribed_ma30, color = "Total Sellers Subscribed")) +
  scale_color_manual(name = "Metrics",
                     values = c("Seller Revenue" = "blue",
                                "Daily Subscription Revenue" = "red",
                                "Olist Rev Share" = "green",
                                "Total Sellers Subscribed" = "purple")) +
  scale_y_continuous(
    name = "30-Day MA Value",
    sec.axis = sec_axis(~ . / scaling_factor, name = "Seller Revenue (Scaled)", 
                        labels = scales::number_format(accuracy = 1))
  ) +
  labs(
    title = "30-Day Moving Averages of Key Metrics Over Time",
    x = "Order Purchase Date",
    color = "Metrics"
  ) +
  theme_minimal()


```

```{r}
summary(final_merged_df_filtered)
```





```{r}
# Create index for headline data chart
# Recalculate the 30-day moving averages for each series
index_summary_df_filtered <- index_summary_df_filtered %>%
  group_by(IndexType) %>%
  mutate(MovingAvg = rollmean(IndexValue, k = 30, fill = NA, align = "right")) %>%
  ungroup()

# Calculate the scaling factor for the seller revenue index
scaling_factor <- max(index_summary_df_filtered$MovingAvg[index_summary_df_filtered$IndexType != 'seller_revenue_index'], na.rm = TRUE) / 
                 max(index_summary_df_filtered$MovingAvg[index_summary_df_filtered$IndexType == 'seller_revenue_index'], na.rm = TRUE)

# Assuming index_summary_df_filtered contains all the necessary data and scaling_factor is defined

# Define the names for the legend
names_for_legend <- c("Total Olist Revenue", "Average Seller Revenue", "Total Sellers Subscribed", "Total Seller Revenue")

# Update the data with the scaled 'seller_revenue_index'
index_summary_df_filtered <- index_summary_df_filtered %>%
  mutate(scaled_seller_revenue = ifelse(IndexType == "seller_revenue_index", MovingAvg * scaling_factor, MovingAvg))

# Create the plot with the correct scaling factor and black color for the 'seller_revenue_index'
final_plot <- ggplot(index_summary_df_filtered, aes(x = order_purchase_date)) +
  geom_line(aes(y = scaled_seller_revenue, color = IndexType), size = 1) +
  scale_y_continuous(
    "Primary Axis (Index Value)",
    sec.axis = sec_axis(~ . / scaling_factor, name = "Total Seller Revenue (Scaled 30-Day Moving Avg)", labels = scales::comma)
  ) +
  scale_color_manual(
    values = c("Total Olist Revenue" = "blue", "Average Seller Revenue" = "green", 
               "Total Sellers Subscribed" = "red", "Total Seller Revenue" = "black"),
    labels = names_for_legend,
    name = ""
  ) +
  labs(title = "Indexed Series with 30-Day Moving Averages (Up to Aug 31, 2018)", 
       x = "Date", y = "Index Value (30-Day Moving Avg)") +
  theme_minimal() +
  theme(legend.title = element_blank(), legend.position = "bottom", axis.text.x = element_text(angle = 45, hjust = 1)) +
  guides(color = guide_legend(title = "Index Type", override.aes = list(size = 3)))

# Print the plot
print(final_plot)



```




```{r}
summary(index_summary_df)
```

