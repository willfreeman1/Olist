```{r}

setwd("C://Users//willf//OneDrive//Documents//NYDSA//R//Olist//Data")

# Looking at various dataframe sizes to understand what I can use


str(orders_items)

```

```{r}
# Create Olist Rev from Sellers DF

# First merge orders and order_items

library(dplyr)
library(tidyr)

orders_items = merge(orders, order_items, by = "order_id")

# Select necessary columns
rev_from_sellers <- orders_items %>%
  filter(order_status == "delivered") %>%
  select(order_id, order_status, order_purchase_timestamp, order_item_id, product_id, seller_id, price, freight_value) %>%
  mutate(order_purchase_timestamp = as.POSIXct(order_purchase_timestamp, format = "%Y-%m-%d %H:%M:%S"))

# Filter out row(s) with missing timestamps
rev_from_sellers <- rev_from_sellers %>%
  filter(!is.na(order_purchase_timestamp))

# Create new vs old sellers
rev_from_sellers <- rev_from_sellers %>%
  group_by(seller_id) %>%
  mutate(
    min_timestamp = min(order_purchase_timestamp),
    seller_status = ifelse(order_purchase_timestamp == min_timestamp, "new", "old")
  ) %>%
  ungroup() %>%
  select(-min_timestamp) 


```


```{r}
library(dplyr)
library(lubridate)

# Assuming 'monthly_seller_stats' has columns: month, new_sellers, lost_sellers, total_sellers_subscribed
# And assuming a fixed daily subscription fee, for simplicity let's assume $99/month as in your example

# Step 1: Directly use monthly_seller_stats for seller acquisition and churn
monthly_seller_changes <- monthly_seller_stats %>%
  select(month, new_sellers, lost_sellers) %>%
  mutate(net_change = new_sellers - lost_sellers)

# Step 2: Calculate the total daily subscription revenue
# Assuming each seller pays for each day they are subscribed within a month
# First, calculate the number of days each month in the data range

monthly_seller_stats_with_days <- monthly_seller_stats %>%
  mutate(days_in_month = days_in_month(month),
         daily_fee_per_seller = 99 / days_in_month)

# Assuming total_sellers_subscribed represents the count of active subscriptions at the end of each month,
# calculate the total daily subscription fee revenue for the SaaS provider
monthly_revenue_from_subs <- monthly_seller_stats_with_days %>%
  mutate(monthly_revenue = total_sellers_subscribed * daily_fee_per_seller * days_in_month)

# Optional: Summarize to get total revenue over the period
total_revenue_from_subs <- sum(monthly_revenue_from_subs$monthly_revenue)

# Now, you can compare this subscription revenue to the percentage of seller sales revenue 
# the SaaS provider takes, assuming you have that revenue calculated elsewhere in `rev_from_sellers`

# Note: This approach assumes a constant subscription rate across the period and does not account for partial months
# for new sellers joining or sellers leaving partway through a month. Adjustments might be necessary for a precise calculation.

```

```{r}
# Since only one timestamp per order we can aggregate main DF by order_id
rev_from_sellers_byorder_delivered <- rev_from_sellers %>%
  filter(order_status == "delivered") %>%
  group_by(order_id) %>%
  summarise(
    total_sales = sum(price),
    total_freight_value = sum(freight_value),
    total_units_ordered = n_distinct(order_item_id),
    order_purchase_timestamp = first(order_purchase_timestamp),
    unique_sellers = n_distinct(seller_id),
    unique_products = n_distinct(product_id),
    new_sellers = sum(seller_status == "new"),
    old_sellers = sum(seller_status == "old"),
    new_seller_sales = sum(ifelse(seller_status == "new", price, 0)),
    new_seller_freight = sum(ifelse(seller_status == "new",freight_value, 0)),
    old_seller_sales = sum(ifelse(seller_status == "old", price, 0)),
    old_seller_freight = sum(ifelse(seller_status == "old", price, 0)),
    olist_rev_share = (total_sales * 0.2)) %>%
    ungroup()
```

```{r}
# Assuming monthly_seller_stats_with_days is your DataFrame and is ready for use
library(dplyr)
library(tidyr)
library(lubridate)

# Generate a sequence of dates for each month and calculate daily subscription revenue
daily_subs_revenue <- monthly_seller_stats_with_days %>%
  rowwise() %>%
  mutate(days = list(seq(as.Date(month), 
                         as.Date(month) + days_in_month(month) - 1, 
                         by = "day"))) %>%
  unnest(days) %>%
  mutate(daily_subscription_revenue = total_sellers_subscribed * daily_fee_per_seller) %>%
  select(days, daily_subscription_revenue)

# Since you're calculating the daily subscription revenue, ensure there are no duplicates
daily_subs_revenue <- daily_subs_revenue %>%
  group_by(days) %>%
  summarise(daily_subscription_revenue = sum(daily_subscription_revenue), .groups = 'drop')

```

```{r}
# Assuming rev_from_sellers_byorder_delivered is prepared and includes daily sales data
# First, ensure order_purchase_timestamp is in Date format
rev_from_sellers_byorder_delivered$order_purchase_timestamp <- as.Date(rev_from_sellers_byorder_delivered$order_purchase_timestamp)

# Aggregate sales data to daily, if not already
rev_from_sellers_daily <- rev_from_sellers_byorder_delivered %>%
  group_by(order_purchase_timestamp) %>%
  summarise(total_sales = sum(total_sales),
            total_freight_value = sum(total_freight_value),
            olist_rev_share = sum(olist_rev_share)) %>%
  ungroup()

# Merge daily subscription revenue
rev_from_sellers_daily <- rev_from_sellers_daily %>%
  left_join(daily_subs_revenue, by = c("order_purchase_timestamp" = "days"))

# Calculate total daily revenue for Olist combining subscription and sales revenue
rev_from_sellers_daily <- rev_from_sellers_daily %>%
  mutate(olist_total_rev = olist_rev_share + coalesce(daily_subscription_revenue, 0))


print(rev_from_sellers_daily)

```

```{r}
library(dplyr)
library(zoo)

# Ensure order_purchase_timestamp is in Date format
rev_from_sellers_daily$order_purchase_timestamp <- as.Date(rev_from_sellers_daily$order_purchase_timestamp)

# Calculate 10-day moving averages for olist_rev_share and daily_subscription_revenue
rev_from_sellers_daily <- rev_from_sellers_daily %>%
  arrange(order_purchase_timestamp) %>%
  mutate(
    olist_rev_share_10DMA = rollmean(olist_rev_share, 10, fill = NA, align = "right"),
    daily_subscription_revenue_10DMA = rollmean(daily_subscription_revenue, 10, fill = NA, align = "right")
  )

# Display the updated DataFrame
print(rev_from_sellers_daily)

```

```{r}
# Calc 10D MA and plot


library(ggplot2)
library(tidyr)

# Reshape the data into a long format
rev_split <- rev_from_sellers_daily %>%
  select(order_purchase_timestamp, olist_rev_share_10DMA, daily_subscription_revenue_10DMA) %>%
  pivot_longer(-order_purchase_timestamp, names_to = "Revenue Type", values_to = "Amount")

# Plotting the stacked area chart
ggplot(rev_split, aes(x = order_purchase_timestamp, y = Amount, fill = `Revenue Type`)) +
  geom_area(position = "stack", alpha = 0.6) +
  scale_fill_manual(values = c("olist_rev_share_10DMA" = "lightcoral", 
                               "daily_subscription_revenue_10DMA" = "steelblue")) +
  labs(title = "10-Day Moving Averages of Olist Revenue Share and Daily Subscription Revenue",
       x = "Date",
       y = "10-Day Moving Average (DMA)",
       fill = "Revenue Type") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

saveRDS(rev_split, "rev_split.rds")


```




```{r}
saveRDS(rev_from_sellers_daily, "..//Data//rev_from_sellers_daily.rds")
```

```{r}
getwd()
```

