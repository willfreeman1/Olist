```{r}
# USE LEAFLET TO VISUALIZE OLIST GEOGRAPHIC DATA

# start with a simple plot of customer sales by municipality
library(leaflet)
library(sf)
library(viridis)

# final_muni_geom_valid = readRDS("..//Scripts//final_muni_geom_valid.rds")

# Explicitly set the geometry column
st_geometry(final_muni_geom_filtered_with_coords) <- final_muni_geom_filtered_with_coords$geom_munis

# Ensure the DF is in sf format
if (!inherits(final_muni_geom_filtered_with_coords, "sf")) {
  final_muni_geom_filtered_with_coords <- st_as_sf(final_muni_geom_filtered_with_coords)
}

# Make sure CRS is correct format
final_muni_geom_filtered_with_coords <- st_transform(final_muni_geom_filtered_with_coords, crs = 4326)

# Convert geometry collections to polygons
final_muni_geom_filtered_with_coords <- st_cast(final_muni_geom_filtered_with_coords, "POLYGON")

# Get the list of columns you want to create maps for (excluding non-numeric columns)
columns_to_map <- colnames(final_muni_geom_filtered_with_coords)[sapply(final_muni_geom_filtered_with_coords, is.numeric)]

# Loop through the columns and create maps
maps <- lapply(columns_to_map, function(column) {
  leaflet(data = final_muni_geom_filtered_with_coords) %>%
    addProviderTiles(providers$CartoDB.Positron) %>%
    addPolygons(
      fillColor = ~colorNumeric(palette = viridis_pal(option = "D")(10), domain = final_muni_geom_filtered_with_coords[[column]])(final_muni_geom_filtered_with_coords[[column]]),
      weight = 2,
      color = "#FFFFFF",
      fillOpacity = 0.7,
      popup = ~paste(column, ": ", final_muni_geom_filtered_with_coords[[column]])
    ) %>%
    addLegend(pal = colorNumeric(palette = viridis_pal(option = "D")(10), domain = final_muni_geom_filtered_with_coords[[column]]), 
              values = ~final_muni_geom_filtered_with_coords[[column]], 
              title = column)
})

# Print the maps
maps

  

```
```{r}
# Simplified dataframe for the Shiny app
final_muni_geom_simplified <- final_muni_geom_valid %>%
  select(year_month, cust_sales_month, geom_munis)

# Ensure it's an sf object with the correct CRS
if (!inherits(final_muni_geom_simplified, "sf")) {
    final_muni_geom_simplified <- st_as_sf(final_muni_geom_simplified)
}
final_muni_geom_simplified <- st_transform(final_muni_geom_simplified, crs = 4326)

saveRDS(final_muni_geom_simplified, "final_muni_geom_simplified.rds")
```

```{r}
library(dplyr)
library(leaflet)
final_geo_df = readRDS("..\\Data\\GCP Geo\\final_geo_df.rds")

# Simplify DF to make map smaller and easier
final_geo_df_sell_sales = final_geo_df %>%
  select(zip_code_prefix, year_month,seller_sales_month, sell_geo_lat,sell_geo_lng) %>%
  filter(year_month == "2018-06-01", 
         !is.na(sell_geo_lat), !is.na(sell_geo_lng), 
         sell_geo_lat >= -90, sell_geo_lat <= 90,
         sell_geo_lng >= -180, sell_geo_lng <= 180)

# Pick a month to show
sample_month_data <- final_geo_df_sell_sales %>%
  filter(year_month == "2018-06-01") %>%
  group_by(zip_code_prefix) %>%
  summarise(
    seller_sales_month = first(seller_sales_month),
    sell_geo_lat = first(sell_geo_lat),
    sell_geo_lng = first(sell_geo_lng)
  ) %>%
  ungroup()

# Categorize sales data into groups (e.g., quintiles)
sales_categories <- cut(sample_month_data$seller_sales_month,
                        breaks = quantile(sample_month_data$seller_sales_month, probs = seq(0, 1, by = 0.1), na.rm = TRUE),
                        include.lowest = TRUE, labels = FALSE)

color_pal <- colorNumeric(palette = "YlOrRd", domain = 1:10) 

# Create leaflet map
leaflet(sample_month_data) %>%
  addTiles() %>%
  addCircleMarkers(
    lng = ~sell_geo_lng,
    lat = ~sell_geo_lat, 
    weight = 3,
    fillColor = ~color_pal(as.numeric(sales_categories)),
    color = ~color_pal(as.numeric(sales_categories)),
    fillOpacity = 0.8,
    radius = 1,
    popup = ~paste("Zip Code: ", zip_code_prefix, "<br>Sales: ", seller_sales_month)
  )



```



```{r}
library(dplyr)
library(leaflet)
final_geo_df <- readRDS("..\\Data\\GCP Geo\\final_geo_df.rds")

# Simplify DF
final_geo_df_sell_sales <- final_geo_df %>%
  select(zip_code_prefix, year_month, seller_sales_month, sell_geo_lat, sell_geo_lng) %>%
  filter(year_month == "2018-06-01", 
         !is.na(sell_geo_lat), !is.na(sell_geo_lng), 
         sell_geo_lat >= -90, sell_geo_lat <= 90,
         sell_geo_lng >= -180, sell_geo_lng <= 180)

# Simplify by taking the first value for each zip code prefix
sample_month_data <- final_geo_df_sell_sales %>%
  group_by(zip_code_prefix) %>%
  summarise(
    seller_sales_month = first(seller_sales_month),
    sell_geo_lat = first(sell_geo_lat),
    sell_geo_lng = first(sell_geo_lng)
  ) %>%
  ungroup()

# Manual categorization of sales data
breaks <- c(-Inf, 100, 300, 1000, 5000, Inf)
labels <- seq_along(breaks)[-length(breaks)]
sample_month_data$sales_category <- cut(sample_month_data$seller_sales_month, breaks = breaks, labels = labels, include.lowest = TRUE)

# Simple color palette
colors <- c("blue", "green","yellow","orange", "red")

# Apply colors to categories
sample_month_data$color <- colors[as.numeric(sample_month_data$sales_category)]

# Print color mapping to console (for troubleshooting)
print(table(sample_month_data$color))

# Create leaflet map
leaflet(sample_month_data) %>%
  addTiles() %>%
  addCircleMarkers(
    lng = ~sell_geo_lng,
    lat = ~sell_geo_lat, 
    weight = 5,
    fillColor = ~color,  # Apply manual colors
    color = ~color,
    fillOpacity = 0.8,
    radius = 1,
    popup = ~paste("Zip Code: ", zip_code_prefix, "<br>Sales: ", seller_sales_month)
)


```


```{r}
# All time seller sales per zip
library(dplyr)
library(leaflet)
final_geo_df <- readRDS("..\\Data\\GCP Geo\\final_geo_df.rds")

# Simplify DF and remove the specific month filter
final_geo_df_all_time_sales <- final_geo_df %>%
  select(zip_code_prefix, seller_sales_month, sell_geo_lat, sell_geo_lng) %>%
  filter(!is.na(sell_geo_lat), !is.na(sell_geo_lng), 
         sell_geo_lat >= -90, sell_geo_lat <= 90,
         sell_geo_lng >= -180, sell_geo_lng <= 180)

# Aggregate data to get sum of sales for each zip code
sum_sales_data <- final_geo_df_all_time_sales %>%
  group_by(zip_code_prefix) %>%
  summarise(
    total_seller_sales = sum(seller_sales_month, na.rm = TRUE),
    sell_geo_lat = first(sell_geo_lat),
    sell_geo_lng = first(sell_geo_lng)
  ) %>%
  ungroup()

# Manual categorization of sales data - keep the same breaks
breaks <- c(-Inf, 100, 300, 1000, 5000, Inf)
labels <- seq_along(breaks)[-length(breaks)]
sum_sales_data$sales_category <- cut(sum_sales_data$total_seller_sales, breaks = breaks, labels = labels, include.lowest = TRUE)

# Reversed color palette
colors <- c("blue", "green", "yellow", "orange", "red")

# Apply reversed colors to categories
sum_sales_data$color <- colors[as.numeric(sum_sales_data$sales_category)]

# Print color mapping to console (for troubleshooting)
print(table(sum_sales_data$color))

# Create leaflet map
leaflet(sum_sales_data) %>%
  addTiles() %>%
  addCircleMarkers(
    lng = ~sell_geo_lng,
    lat = ~sell_geo_lat, 
    weight = 5,
    fillColor = ~color,  # Apply reversed colors
    color = ~color,
    fillOpacity = 0.8,
    radius = 1,
    popup = ~paste("Zip Code: ", zip_code_prefix, "<br>Total Sales: ", total_seller_sales)
)


```


```{r}
final_muni_geom_valid = st_as_sf(final_muni_geom_valid)

geometry_types <- st_geometry_type(final_muni_geom_valid)
table(geometry_types)
```

```{r}
# Troubleshooting errors from shiny that x is not numeric and problem with breaks in quantiles for colors

# Load libraries and read data (replace with your data loading code)
library(sf)

# Read your data (you can replace this with your readRDS code)
# final_muni_geom_filtered_with_coords <- readRDS("C://Users//willf//OneDrive//Documents//NYDSA//R//Olist//Scripts//final_muni_geom_filtered_with_coords.rds")

# Convert geometry collections to polygons
final_muni_geom_filtered_with_coords <- st_cast(final_muni_geom_filtered_with_coords, "POLYGON")

# Define the columns you want to check
columns_to_check <- c("cust_sales_month", "cust_sales_cum", "cust_revenue_month", "cust_rev_cum",
                      "total_cust_month", "new_cust_month", "return_cust_month", "cum_cust_month",
                      "avg_clv", "seller_sales_month", "seller_sales_cum", "seller_revenue_month",
                      "seller_revenue_cum", "active_sellers_month", "active_sellers_cum",
                      "new_sellers_month", "old_sellers_month", "total_seller_lv", "avg_seller_lv")

# Function to check if column values are numeric
check_numeric <- function(column) {
  cat("Column:", column, "\n")
  
  # Extract the column values
  data <- final_muni_geom_filtered_with_coords[[column]]
  
  # Check if all values are numeric
  all_numeric <- all(is.numeric(data))
  
  if (all_numeric) {
    cat("All values are numeric.\n\n")
  } else {
    cat("Not all values are numeric.\n\n")
  }
}

# Function to find the maximum number of quantiles without overlapping breaks
find_max_quantiles <- function(column) {
  cat("Column:", column, "\n")
  
  # Extract the column values
  data <- final_muni_geom_filtered_with_coords[[column]]
  
  # Find the maximum number of quantiles without overlapping breaks
  max_quantiles <- max(unique(data))
  
  cat("Maximum number of quantiles without overlapping breaks:", max_quantiles, "\n\n")
}

# Perform checks for each column
for (col in columns_to_check) {
  check_numeric(col)
  find_max_quantiles(col)
}

```

```{r}
# Find unique non-numeric values in the cust_rev_cum column
unique_non_numeric_cust_rev_cum <- unique(final_muni_geom_filtered_with_coords$cust_rev_cum[!is.numeric(final_muni_geom_filtered_with_coords$cust_rev_cum)])

# Find unique non-numeric values in the return_cust_month column
unique_non_numeric_return_cust_month <- unique(final_muni_geom_filtered_with_coords$return_cust_month[!is.numeric(final_muni_geom_filtered_with_coords$return_cust_month)])

# Find unique non-numeric values in the cum_cust_month column
unique_non_numeric_cum_cust_month <- unique(final_muni_geom_filtered_with_coords$cum_cust_month[!is.numeric(final_muni_geom_filtered_with_coords$cum_cust_month)])

# Display the unique non-numeric values
unique_non_numeric_cust_rev_cum
unique_non_numeric_return_cust_month
unique_non_numeric_cum_cust_month

```

```{r}
names(final_muni_geom_filtered_with_coords)
```

```{r}
# Load necessary libraries
library(dplyr)
library(stargazer)

# Define your dataframe (replace "your_dataframe" with your actual dataframe)
your_dataframe <- final_muni_geom_filtered_with_coords

# List the columns you want to analyze (replace with your actual column names)
columns_to_analyze <- c(
  "total_cust_month", "cust_sales_month", "cust_revenue_month", "new_cust_month",
  "returning_cust_month", "total_cust_cum", "cust_sales_cum", "cust_revenue_cum",
  "active_sellers_month", "new_sellers_month", "old_sellers_month",
  "seller_sales_month", "seller_revenue_month", "active_sellers_cum",
  "seller_sales_cum", "seller_revenue_cum", "total_seller_lv", "avg_clv",
  "avg_seller_lv"
)

# Function to calculate the maximum number of quantiles without overlapping breaks
max_quantiles <- function(x) {
  quantiles <- length(unique(x))
  max_quantiles <- quantiles / max(diff(sort(x)))
  return(max_quantiles)
}

# Calculate the maximum number of quantiles for each specified column
quantile_summary <- lapply(columns_to_analyze, function(column) {
  max_quantiles(your_dataframe[[column]])
})

# Combine the results into a data frame
quantile_summary <- data.frame(column = columns_to_analyze, max_quantiles = unlist(quantile_summary))

# Print the summary
print(quantile_summary)


# Create a data frame from the summary statistics
summary_df <- data.frame(summary(final_muni_geom_filtered_with_coords))

# Print the summary data frame
print(summary_df)

```

```{r}
# Load necessary libraries
library(dplyr)
library(tidyr)

# Assuming 'final_muni_geom_filtered_with_coords' is your dataset
data <- final_muni_geom_filtered_with_coords

# Test function to check for unique year_month values
check_unique_dates <- function(df, column_name) {
  if(any(duplicated(df$Year_Month))) {
    cat(paste("Duplicates found in Year_Month for column:", column_name, "\n"))
  } else {
    cat(paste("No duplicates in Year_Month for column:", column_name, "\n"))
  }
}

# Temporarily drop the 'geom_munis' column
data_without_geom <- data %>% select(-geom_munis)

# Define the columns you want to check
columns_to_check <- c(
  "total_cust_month",
  "cust_sales_month",
  "cust_revenue_month",
  "new_cust_month",
  "returning_cust_month",
  "total_cust_cum",
  "cust_sales_cum",
  "cust_revenue_cum",
  "seller_sales_month",
  "seller_revenue_month",
  "seller_sales_cum",
  "seller_revenue_cum",
  "total_seller_lv",
  "avg_clv",
  "avg_seller_lv"
)

# Create a data frame to store the results
results <- data.frame(Year_Month = character(0), Column = character(0), Min_Value = numeric(0), Max_Value = numeric(0), Num_Quantiles = numeric(0))

# Group by year_month
data_grouped <- data_without_geom %>% group_by(year_month)

for (col_name in columns_to_check) {
  group_results <- data_grouped %>% 
    summarise(
      Min_Value = min(sqrt(!!sym(col_name) + 1), na.rm = TRUE),
      Max_Value = max(sqrt(!!sym(col_name) + 1), na.rm = TRUE),
      Num_Quantiles = length(unique(quantile(sqrt(!!sym(col_name) + 1), probs = seq(0, 1, by = 0.2), na.rm = TRUE))),
      .groups = 'drop'
    ) %>%
    mutate(Column = col_name, Year_Month = as.character(year_month))

  # Combine results
  results <- bind_rows(results, group_results)

  # Check for unique dates
  check_unique_dates(group_results, col_name)
}

# Print and save the final results
print(results)

write.csv(results, "..//Data//max_quantiles_per_month_2.csv", row.names = FALSE)

str(final_muni_geom_filtered_with_coords$year_month)
```
```{r}
library(sf)

# Assuming 'final_muni_geom_filtered_with_coords' is your original dataframe
final_muni_geom_filtered_with_coords_sf <- st_as_sf(final_muni_geom_filtered_with_coords)

# Extract the centroids from the sf object
centroids <- st_coordinates(st_centroid(final_muni_geom_filtered_with_coords_sf))

# Create a data frame for the centroids
centroids_df <- data.frame(
  longitude = centroids[, "X"],
  latitude = centroids[, "Y"]
)

# Join the centroids with your original dataframe
final_muni_geom_filtered_with_coords_with_centroids <- cbind(final_muni_geom_filtered_with_coords, centroids_df)

str(final_muni_geom_filtered_with_coords_with_centroids)
# Save the updated dataframe to a file
saveRDS(final_muni_geom_filtered_with_coords_with_centroids, "..//final_muni_geom_filtered_with_coords_with_centroids.rds")


getwd()

```

